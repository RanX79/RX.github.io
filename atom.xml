<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://RanX79.github.io/</id>
    <title>Ran Xue</title>
    <updated>2024-11-26T07:35:01.797Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://RanX79.github.io/"/>
    <link rel="self" href="https://RanX79.github.io/atom.xml"/>
    <subtitle>æ˜¯å†‰å†‰å‡èµ·çš„å†‰</subtitle>
    <logo>https://RanX79.github.io/images/avatar.png</logo>
    <icon>https://RanX79.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, Ran Xue</rights>
    <entry>
        <title type="html"><![CDATA[NCLè®¡ç®—æ³¢ä½œç”¨å¯†åº¦å€¾å‘æ–¹ç¨‹]]></title>
        <id>https://RanX79.github.io/post/ncl-ji-suan-bo-zuo-yong-mi-du-qing-xiang-fang-cheng/</id>
        <link href="https://RanX79.github.io/post/ncl-ji-suan-bo-zuo-yong-mi-du-qing-xiang-fang-cheng/">
        </link>
        <updated>2024-11-26T07:22:27.000Z</updated>
        <content type="html"><![CDATA[<p>Â·Â·Â·</p>
<pre><code>undef(&quot;def_dAdt&quot;)
;è¾“å…¥ä½æ¶¡çš„æ°”å€™æ€å’Œå¼‚å¸¸åœº
;æ•°æ®ï¼štime lat lon 
function def_dAdt(pv_cli[*][*][*]:numeric,pv_ano[*][*][*]:numeric,youwantlevel)

local pi,dName,lon,lat,level,gradpv,pv_grad_lat,pv_grad_lon,A,opt,dt,t,gradpv2,dQdy,time

begin

pi      = atan(1.0)*4.
dName   = getvardims(pv_cli)

if (any(ismissing(dName(1:)))) then
print(&quot;fatal:  def_DADt: requires that all the rightmost dimensions be named&quot;)
        exit
end if

lat     = pv_cli&amp;$dName(1)$
lon     = pv_cli&amp;$dName(2)$
; cosine
coslat  = cos(lat(:)*pi/180.)
coslat@_FillValue = default_fillvalue(typeof(coslat))
coslat  = (/where(coslat.le.0.,coslat@_FillValue,coslat)/)
; 1-D -&gt; 3-D
coslattmp   = conform_dims(dimsizes(pv_cli),coslat,1)
;------------------------------------------------------

; dQdx    = center_finite_diff_n(pv_cli,lon*pi/180., False,0,2)
dQdy    = center_finite_diff_n(pv_cli,lat*pi/180., False,0,1)
copy_VarMeta(pv_cli, dQdy)

if (any(dQdy.eq.0)) then
    print(&quot;your data: dQdy have zero!!!!&quot;)
end if

;------------------------------------------------------
gradpv       = grad_latlon_cfd(pv_cli, pv_cli&amp;latitude, pv_cli&amp;longitude, True, False)
pv_grad_lat  = gradpv[0]    
pv_grad_lon  = gradpv[1]

copy_VarMeta(pv_cli, pv_grad_lat)
copy_VarMeta(pv_cli, pv_grad_lon)

printVarSummary(pv_grad_lat)
printMinMax(pv_grad_lat, 0)

if (any(pv_grad_lat.eq.0)) then
    print(&quot;your data: pv_grad_lat have zero!!!!&quot;)
end if

if (any(pv_grad_lon.eq.0)) then
    print(&quot;your data: pv_grad_lat have zero!!!!&quot;)
end if


pv_grad_lat =where(pv_grad_lat.eq.0, pv_grad_lat@_FillValue, pv_grad_lat)
pv_grad_lon =where(pv_grad_lon.eq.0, pv_grad_lon@_FillValue, pv_grad_lon)
dQdy        =where(dQdy.eq.0,               dQdy@_FillValue, dQdy)

;------å¡«è¡¥ç¼ºå¤±å€¼
guess     = 1                ; use zonal means
is_cyclic = True             ; cyclic [global]
nscan     = 1500             ; usually much less than this
eps       = 1.e-2            ; variable dependent
relc      = 0.6              ; relaxation coefficient
opt       = 0                ; not used

; poisson_grid_fill( pv_grad_lat, is_cyclic, guess, nscan, eps, relc, opt)
; poisson_grid_fill( pv_grad_lon, is_cyclic, guess, nscan, eps, relc, opt)
; poisson_grid_fill( dQdy, is_cyclic, guess, nscan, eps, relc, opt)

;------------------------------------------------------

re      = 6.37*10^6

gradpv2=sqrt(pv_grad_lat^2+pv_grad_lon^2)
copy_VarMeta(pv_cli, gradpv2)


if (any(gradpv2.eq.0)) then
    print(&quot;your data: gradpv2 have zero!!!!&quot;)
end if
gradpv2=where(gradpv2.eq.0, gradpv2@_FillValue, gradpv2)
;poisson_grid_fill( gradpv2, is_cyclic, guess, nscan, eps, relc, opt)
print(&quot;-----gradpv2-----&quot;)
printMinMax(gradpv2, 0)

;-----3ç§æ–¹æ³•è®¡ç®—A
;A=(youwantlevel*pv_ano^2)/(2.*1000.*gradpv2)

A=(youwantlevel*pv_ano^2*re*coslattmp^2)/(2.*1000.*dQdy)

;A=(1.225*pv_ano^2)/(2.*dQdy)

copy_VarMeta(pv_cli, A)
printVarSummary(A)


print(&quot;-----pv_ano-----&quot;)
printMinMax(pv_ano, 0)
print(&quot;-----pv_ano^2-----&quot;)
printMinMax(pv_ano^2, 0)
print(&quot;-----dQdy-----&quot;)
printMinMax(dQdy^2, 0)
print(&quot;-----A-----&quot;)
printMinMax(A, 0)

;utc     =cd_calendar(pv_cli&amp;$dName(0)$, 2)
;day     = tointeger(utc(:,2))
;day=ispan(0, 60, 1)
;print(utc)

;---Convert &quot;hours since ...&quot; to &quot;seconds since ...&quot;

time    = pv_cli&amp;time   
print(time@units);hours since 1900-01-01 00:00:00

dt = 24.*3600.
t = time*3600.


if(any(ismissing(A))) then
    print(&quot;Your data: A is missing.&quot;)
end if
poisson_grid_fill( A, is_cyclic, guess, nscan, eps, relc, opt)

dAdt    = tofloat(center_finite_diff_n(A,t,False,0,0));æœ€åä¸€ä¸ªæ˜¯æ—¶é—´ç»´ å•ä½s
copy_VarMeta(pv_cli, dAdt)
printVarSummary(dAdt)
printMinMax(dAdt, 0)


return(dAdt)

end
</code></pre>
<p>Â·Â·Â·</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NCLè®¡ç®—æ³¢æŠ˜å°„æŒ‡æ•°]]></title>
        <id>https://RanX79.github.io/post/ncl-ji-suan-bo-zhe-she-zhi-shu/</id>
        <link href="https://RanX79.github.io/post/ncl-ji-suan-bo-zhe-she-zhi-shu/">
        </link>
        <updated>2024-06-16T03:07:25.000Z</updated>
        <content type="html"><![CDATA[<p>å»å¹´ç ”ç©¶äº†æ³¢æŠ˜å°„æŒ‡æ•°çš„è®¡ç®—å…¬å¼ï¼Œå½“æ—¶è§‰å¾—å¤ªå¤æ‚äº†ä¸æƒ³å†™ä»£ç äºæ˜¯æ”¾å¼ƒï¼Œä½†ä»Šå¹´çªç„¶åˆè§‰å¾—è¿˜æ˜¯ç®—ä¸€ä¸‹ï¼Œäºæ˜¯åˆç ”ç©¶äº†å‡ å¤©ï¼Œåˆè¢«æŠ˜ç£¨äº†ä¸€ä¸‹ã€‚äººæœç„¶ä¸èƒ½å·æ‡’ï¼</p>
<p>åˆ©ç”¨æ³¢æŠ˜å°„æŒ‡æ•°è¯Šæ–­æ³¢çš„ä¼ æ’­ç¯å¢ƒï¼Œè®¡ç®—æ–¹æ³•:(Andrews et al.,1987)<br>
<img src="https://RanX79.github.io//post-images/1718507275798.png" alt="" loading="lazy"><br>
å…¬å¼éƒ½å·®ä¸å¤šï¼Œä½†Weinberger et al.,(2021)è¿™ç¯‡æ–‡ç« é‡Œé¢æ”¹å˜äº†å¥½å‡ ä¸ªå½¢å¼ï¼Œæˆ‘å°±ç®—äº†ä¸€ä¸ªæ¯”è¾ƒåŸå§‹çš„ã€‚<br>
<img src="https://RanX79.github.io//post-images/1718507323352.png" alt="" loading="lazy"><br>
æ³¢æŠ˜å°„æŒ‡æ•°ä½“ç°å¤§æ°”ç¯æµçš„èƒŒæ™¯åœºæ˜¯å¦æœ‰åˆ©äºè¡Œæ˜Ÿæ³¢ä¼ æ’­ï¼›ä½†å…¶è®¡ç®—æ˜¯åŸºäºçº¬åœˆå¹³å‡çš„åœºï¼Œå®é™…æ³¢çš„åå°„ä¼ æ’­æ˜¯ä¸€ä¸ªå±€åœ°çš„åŒºåŸŸç°è±¡ï¼Œæ³¢æŠ˜å°„æŒ‡æ•°åªèƒ½åˆ¤æ–­èƒŒæ™¯æµæ˜¯å¦æœ‰åˆ©äºæ³¢åŠ¨åå°„ï¼Œä½†æ— æ³•å‡†ç¡®åœ°è¡¨å¾æ³¢åŠ¨åå°„çš„å‘ç”Ÿï¼Œå½“RIï¼œ0æ—¶ï¼Œè¡Œæ˜Ÿæ³¢å‘ç”Ÿåå°„ï¼›RIï¼0ï¼Œè¡Œæ˜Ÿæ³¢åœ¨æ­¤åŒºåŸŸä¼ æ’­ï¼Œè¶Šå¤§è¶Šå®¹æ˜“ä¼ æ’­ï¼›(æ³¨æ„æ˜¯æ³¢æŠ˜å°„æŒ‡æ•°çš„å¹³æ–¹RIï¼Œçœ‹æ–‡çŒ®å¥½åƒæ²¡æœ‰æ‰¾åˆ°è¯†åˆ«å±€åœ°åŒºåŸŸåå°„çš„æŒ‡æ•°ï¼Œè¿˜çœ‹è§ä¸€ä¸ªU2-U10çš„å®šä¹‰ï¼Œæ„Ÿè§‰æ˜¯é£åœºçš„åˆ‡å˜ï¼Œå®šä¹‰æ–¹æ³•æ¯”è¾ƒç²—ç³™ï¼‰ã€‚</p>
<p>Albers and Birner., (2014)æ–‡ç« ä¸­RIçš„å•ä½æ˜¯m-2ï¼Œæ ¹æ®(f/2NH)2ï¼Œfå•ä½ä¸ºs-1ï¼ŒNNå•ä½ä¸ºs-2ï¼ŒHå•ä½ä¸ºmï¼Œå€’æ¨ç¬¬ä¸‰é¡¹å•ä½ä¸ºm-2ï¼Œåˆç†ï¼›è®¡ç®—ç»“æœä¹˜äº†åœ°çƒåŠå¾„çš„å¹³æ–¹ï¼Œå°†RIæ— é‡çº²åŒ–ï¼›æ„Ÿè§‰å…¬å¼ç®—å‡ºæ¥é‡çº§æœ‰ä¸€ç‚¹å¥‡æ€ªï¼Œç®—å‡ºæ¥ä¸»è¦è¿˜æ˜¯ä»¥ä½æ¶¡ç¬¬ä¸€é¡¹ä¸ºä¸»å¯¼çš„æ ·å­ï¼›</p>
<p>(All fields are multiplied by Earthâ€™s radius squared, which nondimensionalizes the refractive index and gives the PV gradient the units of meters per second)<br>
<img src="https://RanX79.github.io//post-images/1718507355770.png" alt="" loading="lazy"><br>
æµ…æµ…çš„ç”¨nclç®—äº†ä¸€ä¸‹ï¼Œç»“æœæ„Ÿè§‰çœ‹èµ·æ¥è¿˜ç®—æ­£å¸¸ï¼Ÿä½†æ˜¯ç¬¬ä¸€é¡¹é‡çº§æœ‰ä¸€ç‚¹é—®é¢˜ï¼›çœŸçƒ¦äººå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šçœ‹äº†ä¸€ä¸‹æ–‡çŒ®ä¸­çš„é‡çº§å·®ä¸å¤š(Li et al.,2017)<br>
<img src="https://RanX79.github.io//post-images/1718507380531.png" alt="" loading="lazy"><br>
Li et al.,2017æ–‡ç« ä¸­è¯´æ­£è´ŸæŠ˜å°„æŒ‡æ•°çš„å¹³æ–¹ä¼šç›¸äº’æŠµæ¶ˆï¼Œæ–°å®šä¹‰ä¸€ä¸ªè´Ÿæ³¢æŠ˜å°„æŒ‡æ•°å¹³æ–¹çš„é¢‘ç‡Fn2æ¥è¯Šæ–­è¡Œæ˜Ÿæ³¢çš„ä¼ æ’­ï¼Œå…·ä½“çš„è®¡ç®—æ–¹æ³•ï¼Œå°†æ ¼ç‚¹ä¸Šn2ä¸ºè´Ÿå€¼çš„ä¸€å¤©å®šä¹‰ä¸º1ï¼Œä¸ºæ­£å€¼çš„ä¸€å¤©å®šä¹‰ä¸º0ï¼ŒFn2å®šä¹‰ä¸ºè´Ÿå€¼çš„å¤©æ•°é™¤ä»¥æ€»å¤©æ•°ï¼ŒFn2åˆæˆçš„ç»“æœå‡å»æ°”å€™æ€çš„å¾—åˆ°å¼‚å¸¸å€¼ï¼Œè¡Œæ˜Ÿæ³¢åœ¨Fn2å°çš„åŒºåŸŸä¼ æ’­ï¼Œåœ¨å¤§çš„åŒºåŸŸåå°„ï¼›<br>
<img src="https://RanX79.github.io//post-images/1718507418767.png" alt="" loading="lazy"><br>
Â·Â·Â·<br>
;============================================================<br>
; calculate QG RI index(Andrews et al.,1987)<br>
;============================================================<br>
;pv:potential vorticity;<br>
;T :basic state of air temperature;<br>
;u :basic state of  uwind;<br>
;k :zonal wavenumber(k=1 means wave 1)<br>
;Two methods:By using the pv data and calculting the pv;<br>
;if the phase speed c equals zero, the RI is treated as the stationary wave RI;<br>
;return:RI Uyy  Uzz RI1<br>
undef(&quot;def_cal_QGRI&quot;)<br>
function def_cal_QGRI(pv[<em>][</em>][<em>][</em>]:numeric,T[<em>][</em>][<em>][</em>]:numeric,u[<em>][</em>][<em>][</em>]:numeric,k[*]:numeric)<br>
local sclhgt,gc,pi,dName,level,lat,lon,re,f,density,coslat,leveltmp,coslattmp,ftmp,dthetadz,NN,pv_ZonalMean,u_ZonalMean,T_ZonalMean,k,T_ZonalMean,densitytmp,u_grad,uyy1,u_gradz,uzz1,pv_grad2,RI2,RI3</p>
<pre><code>begin
;------ scale height
sclhgt  = 7000.;units:m
; Gas constant
gc      = 290.
pi      = atan(1.0)*4.
; è‡ªè½¬è§’é€Ÿåº¦
wmg=2.*pi/(60.*60.*24.)


dName   = getvardims(pv)
level   = pv&amp;$dName(1)$
lat     = pv&amp;$dName(2)$
lon     = pv&amp;$dName(3)$
dim     =dimsizes(T)


;------Radius of the earth
re      = 6.37*10^6 ;6378388 units:m
;------Coriolis parameter
f       = lat(:)
f       = (/2.*2.*pi/(60.*60.*24.)*sin(pi/180.*f)/)

;------ cosine
coslat  = cos(lat(:)*pi/180.)
coslat@_FillValue = default_fillvalue(typeof(coslat))
coslat  = (/where(coslat.le.0.,coslat@_FillValue,coslat)/)



;zanal ano
T_ZonalMean=dim_avg_n_Wrap(T, 3)
printVarSummary(T_ZonalMean)


; 1-D -&gt; 3-D
leveltmp    = conform_dims(dimsizes(T_ZonalMean),level,1)
coslattmp   = conform_dims(dimsizes(T_ZonalMean),coslat,2)
ftmp        = conform_dims(dimsizes(T_ZonalMean),f,2)
;densitytmp = conform_dims(dimsizes(T_ZonalMean),density,1)


;Ï0=Ïs*exp(-z/H)
densitytmp=1.2*(leveltmp/1000)


printVarSummary(leveltmp)  
printVarSummary(coslattmp)  
printVarSummary(ftmp)      
printVarSummary(densitytmp)
;-------------------------------------------------------------------------------
; vertical gradient of potential temperature  (K/m)
dthetadz = center_finite_diff_n(T_ZonalMean*(1000./leveltmp)^0.286,-sclhgt*log(level/1000.),False,0,1)
printVarSummary(dthetadz)


;--------------------------------------------------------------------
; Brunt Vaisala frequency
NN      = (gc*(leveltmp/1000.)^0.286)/sclhgt * dthetadz
NN@var_desc     = &quot;Brunt Vaisala frequency&quot;
NN@units        = &quot;1/s^2&quot;
NN@long_name    = &quot;basic state Brunt Vaisala frequency (TN2001)&quot;
NN@_FillValue   = T@_FillValue
NN              = where(NN.gt.0,NN,NN@_FillValue)
printVarSummary(NN)
print(&quot;-----NN-----&quot;)
printMinMax(NN, 0)


;------ zonal-mean zonal wind
u_ZonalMean=dim_avg_n_Wrap(u, 3)
printVarSummary(u_ZonalMean)
print(&quot;-----u_ZonalMean-----&quot;)
printMinMax(u_ZonalMean, 1)


;------------------------------------------------------------------------------------------------
;---------------------------æ±‚zonal meançš„pvç»å‘æ¢¯åº¦ pv_grad
;ç¬¬1é¡¹ï¼š2*è‡ªè½¬è§’é€Ÿåº¦/åœ°çƒåŠå¾„*cosçº¬åº¦
pv_grad1 =2.*wmg/re*coslattmp
print(&quot;------pv_grad1-----&quot;)
printMinMax(pv_grad1, 0)


;æ³¨æ„æ²¡æœ‰åŠ è´Ÿå·ï¼-uyy -uzz
;-----ç¬¬2é¡¹ï¼šuyy
u_grad  =center_finite_diff_n(u_ZonalMean*coslattmp ,lat*pi/180.,False,0,2)
uyy1    =center_finite_diff_n(u_grad/coslattmp      ,lat*pi/180.,False,0,2)

uyy     =1./(re^2)*uyy1
print(&quot;-----uyy-----&quot;)
printMinMax(uyy, 0)  



;-----ç¬¬3é¡¹ï¼šuzz
u_gradz     =center_finite_diff_n(u_ZonalMean,-sclhgt*log(level/1000.),False,0,1)
printVarSummary(u_gradz)  
uzz1        =center_finite_diff_n(u_gradz*densitytmp/NN,-sclhgt*log(level/1000.),False,0,1)
printVarSummary(uzz1)    


uzz=ftmp^2/densitytmp*(uzz1)
print(&quot;-----uzz-----&quot;)
printMinMax(uzz, 0)



print(&quot;-----cal pv_grad-----&quot;)
pv_grad=(/pv_grad1-uyy-uzz/)


printMinMax(pv_grad, 0)
copy_VarCoords(u_ZonalMean, pv_grad)
printVarSummary(pv_grad)
;=======================================================================
;ç›´æ¥ä½¿ç”¨pvçš„æ•°æ®è®¡ç®—
;--------------------------------------------
pv_grad2=grad_latlon_cfd(pv, lat*pi/180., lon*pi/180., True, False)
;0ä¸ºç»å‘æ¢¯åº¦
printVarSummary(pv_grad2)
;------ å¯¹lonç»´ zonal-mean potential vorticity
pv_ZonalMean=dim_avg_n_Wrap(pv_grad2[0], 3)
print(&quot;-----data pv_grad-----&quot;)
printMinMax(pv_ZonalMean, 0)
printVarSummary(pv_ZonalMean)
;=======================================================================
;------QG RI index for the stationary wave k(c=0)

print(&quot;-----RI1-----&quot;)
RI1=pv_grad/u_ZonalMean ;æœ‰ä¸€ç‚¹é—®é¢˜æ„Ÿè§‰ï¼ä¸ºä»€ä¹ˆé‡çº§å·®å¼‚è¿™ä¹ˆå¤šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šï¼ï¼ï¼ï¼ï¼ï¼10^-10/10^1 é‡çº§ä¸å¯¹å“‡å•Šå•Šå•Šå•Šï¼
printMinMax(RI1, 0)     ;
copy_VarCoords(u_ZonalMean, RI1)


print(&quot;-----RI2-----&quot;)
RI2=(k/(re*coslattmp))^2
printMinMax(RI2, 0)


print(&quot;-----RI3-----&quot;)
RI3=(ftmp/(2.*sclhgt))^2/NN
printMinMax(RI3, 0)



print(&quot;-----RI-----&quot;)
RI=(/RI1-RI2-RI3/)
printVarSummary(RI)
printMinMax(RI, 0)


RI=RI*re^2  ;*åœ°çƒåŠå¾„çš„å¹³æ–¹ï¼Œå°†æŠ˜å°„ç‡æ— é‡çº²åŒ–(Albers and Birner,2014)ï¼›
;æ ¹æ®(f/2NH)^2 få•ä½ä¸ºs-1ï¼ŒNNå•ä½ä¸ºs-2ï¼ŒHå•ä½ä¸ºmï¼Œå€’æ¨ç¬¬ä¸‰é¡¹å•ä½ä¸ºm-2ï¼Œåˆç†ï¼
copy_VarCoords(T_ZonalMean, RI)
RI@units = &quot;1&quot;
RI@long_name = &quot;QGRI&quot;
;--------------------ä¸çŸ¥é“è¿”å›uyyå’Œuzzæ—¶éœ€ä¸éœ€è¦è¿™æ ·å¤„ç†ï¼Œè¾“å‡ºçœ‹ä¸€ä¸‹ç»“æœï¼
uyy=-uyy*re^2
uzz=-uzz*re^2


pv_grad=pv_grad*re^2


RI1=RI1*re^2


copy_VarCoords(T_ZonalMean, uyy)
copy_VarCoords(T_ZonalMean, uzz)
uyy@long_name = &quot;uyy&quot;
uzz@long_name = &quot;uzz&quot;


copy_VarCoords(T_ZonalMean, pv_grad)
pv_grad@long_name = &quot;pv_grad&quot;
pv_grad@units = &quot;m/s&quot;


copy_VarCoords(T_ZonalMean, RI1)
RI1@long_name = &quot;RI1&quot;

print(&quot;-----re2-----&quot;)
printMinMax(RI, 0)
return([/RI,uyy,uzz,pv_grad,RI1/])
end
</code></pre>
<p>ä»£ç åŒ…æ‹¬ç›´æ¥ç”¨pvæ•°æ®è®¡ç®—æ¢¯åº¦å’Œç”¨å…¬å¼è®¡ç®—çš„ï¼Œæ”¹ä¸€ä¸‹è¾“å…¥å°±è¡Œï¼Œè¾“å‡ºçš„å˜é‡éœ€è¦å•¥å°±è¾“å‡ºå•¥ï¼</p>
<p>å‚è€ƒæ–‡çŒ®ï¼š</p>
<p>Andrews, D. G., J. R. Holton, and C. B. Leovy, 1987: Middle Atmosphere Dynamics. International Geophysics Series, Vol. 40, Academic Press, 489 pp.</p>
<p>Albers, J.R., Birner, T., 2014. Vortex Preconditioning due to Planetary and Gravity Waves prior to Sudden Stratospheric Warmings. Journal of the Atmospheric Sciences 71, 4028â€“4054.. https://doi.org/10.1175/jas-d-14-0026.1</p>
<p>Li, Q., Graf, H.-F., &amp; Giorgetta, M. A. (2007). Stationary planetary wave propagation in Northern Hemisphere winter-climatological analysis of the refractive index. Atmospheric Chemistry and Physics, 7(1), 183â€“200. https://doi.org/10.5194/acp-7-183-2007</p>
<p>Weinberger, I., Garfinkel, C.I., White, I.P., Birner, T., 2021. The Efficiency of Upward Wave Propagation near the Tropopause: Importance of the Form of the Refractive Index. Journal of the Atmospheric Sciences 78, 2605â€“2617.. https://doi.org/10.1175/jas-d-20-0267.1</p>
<script 
        src="https://utteranc.es/client.js"
        repo="RanX79/RanX79.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NCLè®¡ç®—plumbæ³¢æ´»åŠ¨é€šé‡]]></title>
        <id>https://RanX79.github.io/post/ncl-ji-suan-plumb-bo-huo-dong-tong-liang/</id>
        <link href="https://RanX79.github.io/post/ncl-ji-suan-plumb-bo-huo-dong-tong-liang/">
        </link>
        <updated>2024-06-16T02:52:27.000Z</updated>
        <content type="html"><![CDATA[<p>ğŸ˜€å¼€å¿ƒï¼Œä»Šå¤©ç»ˆäºé…ç½®å¥½äº†è¯„è®ºï¼ï¼ï¼æœ¬æ¥åœ¨å¾®ä¿¡å…¬ä¼—å·å°±æ˜¯ä¸ºäº†è¯„è®ºï¼ç»“æœæ²¡æ³¨æ„ç°åœ¨æ”¹ç‰ˆä¸èƒ½è¯„è®ºäº†ï¼å°±å¾ˆçƒ¦ï¼æ‰€ä»¥ç»§ç»­åŒæ­¥githubçš„å†…å®¹ï¼</p>
<p>å› ä¸ºè€å¸ˆè¯´TNé€šé‡çš„å‘ä¸‹ä¸ä¸€å®šæ˜¯æ³¢æ´»åŠ¨é€šé‡å‘ä¸‹ä¼ æ’­ï¼å¯èƒ½æ˜¯å‘ä¸Šçš„å‡å°‘ï¼Œå…¶å¼‚å¸¸æ˜¯å‡å»äº†æ°”å€™å¸¦çš„ç»“æœï¼ŒKoderaè¿™ç¯‡æ–‡ç« ä¸­ä¹Ÿæåˆ°äº†è¿™ä¸ªï¼›<br>
<img src="https://RanX79.github.io//post-images/1718506930875.png" alt="" loading="lazy"><br>
æ‰€ä»¥ç°åœ¨è®¡ç®—äº†ä¸€ä¸‹Plumbçš„ç»“æœï¼Œplumbæ˜¯çº¬å‘åå·®ï¼ŒåŒ…å«äº†æ—¶é—´çš„æ€»åœºã€‚ä½†æ˜¯ä¸çŸ¥é“è¿™ä¸¤è€…ç®—å‡ºæ¥å·®å¼‚ä¼šä¸ä¼šå¾ˆå¤§ï¼æŒ‰ç†è¯´æ„Ÿè§‰åº”è¯¥ä¸ä¼šå¤ªå¤§å§ï¼<br>
2008-Kodera., et al.,-GRL-Tropospheric impact of reflected planetary waves from the stratosphere.<br>
<img src="https://RanX79.github.io//post-images/1718506949849.png" alt="" loading="lazy"><br>
<img src="https://RanX79.github.io//post-images/1718506962695.png" alt="" loading="lazy"></p>
<p>ç»“æœå’Œæ‘¸é±¼çš„å¯¹æ¯”äº†ä¸€ä¸‹ï¼Œå¤§ä½“è¶‹åŠ¿å·®ä¸å¤šï¼Œä½†æ˜¯å‚ç›´æ–¹å‘æ²¡æœ‰éªŒè¯ï¼Œæœ‰é—®é¢˜è”ç³»æˆ‘ã€‚</p>
<pre><code>;///////////////////////////////////////////////////////////////
;  Calculate 3-D wave-activity flux:plumb[1985]
;///////////////////////////////////////////////////////////////
;  Written by Ran,20240606.
;  E-mail: 602023280016@nju.edu.cn

;If there is a problem with the code calculation, please contact me by email.

;Input dataï¼šhgt t u v

;Note that the data downloaded by ERA5 is the gravitational potential (unites:m^2/s^2).
;The ncep data is the gravity potential height z, which needs to be multiplied by g.

;Input data must include the entire longitudeï¼ï¼ï¼Because to take the zonal deviation!!

;Return value -  Four multi-dimentional arrays containing:
;                    x-component:  Fx
;                    y-component:  Fy
;                    z-component:  Fz
;                    z_ano

;Usage: [/Fx,Fy,Fz,z_ano/] = plumb_pLLL(hgt,t,u,v)


undef(&quot;plumb_pLLL&quot;)
function plumb_pLLL(hgt[*][*][*][*]:numeric,t[*][*][*][*]:numeric,u[*][*][*][*]:numeric,v[*][*][*][*]:numeric)
local re,sclhgt,k,pi,dName,level,lat,lon,f,wmg,ga,z,coslat,sin2lat,leveltmp,ftmp,coslattmp,sin2lattmp,t_ano,u_ano,v_ano,t_mean,dt_meandz,\
        S,Stmp,dvzdlon,duzdlon,dtzdlon
begin
;åŸºæœ¬é‡

; Radius of the earth
re      = 6.37*10^6;6378388

; scale height
sclhgt  = 8000.

k=0.286

; pi
pi      = atan(1.0)*4.
printVarSummary(hgt)
dName   = getvardims(hgt)
if (any(ismissing(dName(1:)))) then
   print(&quot;fatal: plumb_pLLL: requires that all the rightmost dimensions be named&quot;)
   exit
end if
    level   = hgt&amp;$dName(1)$
    lat     = hgt&amp;$dName(2)$
    lon     = hgt&amp;$dName(3)$

; Coriolis parameter
f       = lat(:)
f       = (/2.*2.*pi/(60.*60.*24.)*sin(pi/180.*f)/)
f@_FillValue = hgt@_FillValue

;Rotational angular velocity of the earth
wmg=2.*pi/(60.*60.*24.) 

; Gravitational acceleration
ga      = 9.80665
z=hgt*ga
copy_VarMeta(hgt, z)
; cosine
coslat  = cos(lat(:)*pi/180.)
coslat@_FillValue = default_fillvalue(typeof(coslat))
coslat  = (/where(coslat.le.0.,coslat@_FillValue,coslat)/)

; sin2lat
sin2lat  = sin(2*(lat(:)*pi/180.))
sin2lat@_FillValue = default_fillvalue(typeof(sin2lat))
sin2lat  = (/where(sin2lat.le.0.,sin2lat@_FillValue,sin2lat)/)


; 1-D -&gt; 4-D
leveltmp   = conform_dims(dimsizes(hgt),level,1)
ftmp       = conform_dims(dimsizes(hgt),f,2)
coslattmp  = conform_dims(dimsizes(hgt),coslat,2)
sin2lattmp = conform_dims(dimsizes(hgt),sin2lat,2)
;Zonal deviation
t_ano   =dim_rmvmean_n_Wrap(t, 3)
u_ano   =dim_rmvmean_n_Wrap(u, 3)
v_ano   =dim_rmvmean_n_Wrap(v, 3)
z_ano   =dim_rmvmean_n_Wrap(z, 3)
;printVarSummary(t_ano)
;printVarSummary(z_ano)

;Zonal mean
t_mean=dim_avg_n_Wrap(t, 3)
dt_meandz = center_finite_diff_n(t_mean,-sclhgt*log(level/1000.),False,0,1)


S=dt_meandz+k*t_mean/sclhgt;
copy_VarCoords_1(hgt, S)
;printVarSummary(S)
; 3-D -&gt; 4-D
Stmp = conform_dims(dimsizes(hgt),S,(/0,1,2/))
;printVarSummary(Stmp)

; dvz/dlon
dvzdlon      =  center_finite_diff_n(v_ano*z_ano,lon*pi/180.,True,0,3)
; duz/dlon
duzdlon      =  center_finite_diff_n(u_ano*z_ano,lon*pi/180.,True,0,3)
; dtz/dlon
dtzdlon      =  center_finite_diff_n(t_ano*z_ano,lon*pi/180.,True,0,3)

;printVarSummary(sin2lattmp)
;printVarSummary(dvzdlon)
;printVarSummary(wmg)
;printVarSummary(coslattmp)

; x-component
Fx      = leveltmp/1000.*coslattmp*(v_ano*v_ano-1./(2.*wmg*re*sin2lattmp)*dvzdlon)
;printVarSummary(Fx)

; y-component
Fy      = leveltmp/1000.*coslattmp*(-u_ano*v_ano+1./(2.*wmg*re*sin2lattmp)*duzdlon)

; z-component
Fz      = leveltmp/1000.*coslattmp*(ftmp/Stmp*(v_ano*t_ano-1./(2.*wmg*re*sin2lattmp)*dtzdlon))

copy_VarCoords(hgt,Fx)
copy_VarCoords(Fx,Fy)
copy_VarCoords(Fx,Fz)

Fx@units = &quot;m^2/s^2&quot;
Fx@var_desc = &quot;wave-activity flux&quot;
Fx@long_name = &quot;x-component of wave-activity flux (Plumb1985)&quot;

Fy@units = &quot;m^2/s^2&quot;
Fy@var_desc = &quot;wave-activity flux&quot;
Fy@long_name = &quot;y-component of wave-activity flux (Plumb1985)&quot;

Fz@units = &quot;Pa m/s^2&quot;
Fz@var_desc = &quot;wave-activity flux&quot;
Fz@long_name = &quot;z-component of wave-activity flux (Plumb1985)&quot;

return [/Fx,Fy,Fz,z_ano/]

end
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://RanX79.github.io//post-images/1718507171115.png" alt="" loading="lazy"></figure>
<script src="https://utteranc.es/client.js"
        repo="RanX79/RanX79.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nclç”»æ–œå‰–é¢]]></title>
        <id>https://RanX79.github.io/post/ncl-hua-xie-pou-mian/</id>
        <link href="https://RanX79.github.io/post/ncl-hua-xie-pou-mian/">
        </link>
        <updated>2024-03-15T06:23:54.000Z</updated>
        <content type="html"><![CDATA[<p>è¶ç€ä»Šå¤©é¡ºåˆ©æŒ‚ä¸Šäº†githubï¼Œèµ¶ç´§åŒæ­¥ä¸€ä¸‹ï¼</p>
<p>ä¸»è¦å‚è€ƒnclå®˜ç½‘ä¸­çš„ä¾‹å­ï¼š<a href="https://www.ncl.ucar.edu/Applications/height_lat.shtml">narr_5.ncl</a>ï¼Œä½†è¯¥ä¾‹å­å¤šäº†å¯¹æ›²é¢ç½‘æ ¼æ•°æ®çš„å¤„ç†,é¦–å…ˆåˆ©ç”¨äº†ESMF_regrid_with_weightsè¿›è¡Œç½‘æ ¼åŒ–ç”Ÿæˆç›´çº¿ç½‘æ ¼ï¼Œå¦‚æœç”¨å†åˆ†æèµ„æ–™ä¸ªäººè§‰å¾—å¯ä»¥ä¸ç”¨è¿™ä¸€æ­¥ã€‚</p>
<p>ä¸»è¦åˆ†ä¸ºä¸¤æ­¥ï¼Œé¦–å…ˆæ˜¯å¤§åœ†è·¯å¾„ï¼Œä¸»è¦ä½¿ç”¨nclä¸­gc_latlonè¿™ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸­è®¾ç½®å˜é‡æ—¶æœ‰ä¸€ä¸ªå¸¸æ•°nptsï¼Œä¸ºxè½´çš„ç‚¹æ•°ï¼Œæ ¹æ®éœ€è¦è®¾ç½®ï¼Œä¸€èˆ¬è®¾ç½®è¶Šå¤§æ•°æ®è¶Šå¯†ã€‚æ¥ä¸‹æ¥è¿›è¡Œæ’å€¼ï¼Œä½¿ç”¨åŒçº¿æ€§æ’å€¼ä»ç›´çº¿ç½‘æ ¼æ’å€¼åˆ°éç»“æ„åŒ–ç½‘æ ¼ï¼Œä½¿ç”¨linint2_points_Wrapè¿™ä¸ªå‡½æ•°ã€‚</p>
<p>åœ¨å®é™…ç”»å›¾ä¸­ï¼Œé‡åˆ°çš„é—®é¢˜æ˜¯æœ€åç”»å›¾è®¾ç½®çš„ç»çº¬åº¦ï¼Œå› ä¸ºåœ°çƒæ˜¯çƒé¢ï¼Œæ‰€ä»¥ç»çº¬åº¦ä¸æ˜¯å‡åŒ€çš„ï¼Œè®¾ç½®æ—¶éœ€è¦ç”»gc_latlon å‡½æ•°å¯¹åº”çš„ç»çº¬åº¦ã€‚åœ¨é€‰æ‹©çš„ç»åº¦èŒƒå›´è·¨è¶ŠåŠçƒæ—¶ï¼Œä¸¤ç‚¹ä¹‹é—´çš„æ–¹å‘ä¸å¯æ§åˆ¶ï¼Œè¿™æ˜¯å› ä¸ºgc_latlonè¿™ä¸ªå‡½æ•°çš„é—®é¢˜ï¼Œè¯•äº†å¤šæ¬¡ä¹Ÿæ²¡è§£å†³ï¼Œåªèƒ½é€‰æ‹©ä¸è·¨è¶ŠåŠçƒäº†ã€‚<br>
If the two specified points are exactly opposite one another on the globe, the code does not fail, but the direction of the great circle route will be somewhat unpredictable. Setting npts &lt;= 2 has the effect of just calculating the great circle distance between the two input points. No lat/lon points will be interpolated in between.<br>
æœ€åå‡ºç°çš„è­¦å‘Šï¼ŒçŒœæµ‹æ˜¯ç”±äºç½‘æ ¼çš„ä¸å‡åŒ€åˆ†å¸ƒé€ æˆçš„ï¼Œä½†å¯¹ç”»å›¾çš„ç»“æœå¥½åƒæ²¡æœ‰å½±å“ã€‚<br>
warning:ScalarFieldSetValues: irregular coordinate array sfXArray non-monotonic: defaulting sfXArray<br>
æ›´æ–°ä¸€ä¸‹ï¼Œæœ€åå‡ºç°çš„è­¦å‘Šæ˜¯å› ä¸ºæˆ‘ï¼å†™ä»£ç çš„æ—¶å€™å¿˜è®°åˆ æ‰cyclic=&quot;True&quot;è¿™ä¸€è¡Œè®¾ç½®äº†ï¼æ‰€ä»¥åæ ‡å°±ä¼šå‡ºç°è­¦å‘Šï¼ï¼ˆé—®é¢˜ä¸å¤§</p>
<pre><code>;=================================================================

;----------------æ–œåˆ¨é¢

;  calculate great circle along transect

npts=600 ;The actual number of interpolated points is npts-2.

N1=npts-1

nLabels      = 5   ;xè½´åæ ‡æƒ³è¦çš„æ ‡ç­¾æ•°ç›®

fiCyclicX    =True ;æ³¨æ„æ•°æ®æ˜¯å¦å¾ªç¯

;é€‰å–çš„ä¸¤ä¸ªç‚¹

leftlat  =  45

rightlat =  80

leftlon  =  300

rightlon =  357.5

;attention:æ•°æ®æ˜¯ä»0-360 or -180-180

;lonFlip å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°è½¬æ¢

dist = gc_latlon(leftlat,leftlon, rightlat,rightlon, npts,2) ;å¤§åœ†è·¯å¾„

;æ’å€¼ å˜é‡ä¸ºFx_pos_10_area

xlon=Fx_pos_10_area&amp;lon

xlat=Fx_pos_10_area&amp;lat

Fx_pos_10_cross = linint2_points_Wrap(xlon,xlat,Fx_pos_10_area,fiCyclicX,dist@gclon,dist@gclat,2)

;æ’å€¼åèµ‹äºˆå˜é‡å±æ€§

Fx_pos_10_cross!0      = &quot;time&quot;

Fx_pos_10_cross!1      = &quot;level&quot;

Fx_pos_10_cross&amp;level= Fx_pos_10_area&amp;level

;-----å¯¹åº”çš„ç»çº¬åº¦

latXsecUser  = dist@gclat      ; convenience

lonXsecUser  = dist@gclon

print (dist@gclat+&quot;  &quot;+dist@gclon )  ; print the lats/lons

;--------ç”»å›¾æ—¶xè½´åæ ‡è®¾ç½®

;æ•°æ®ä»0-360

XBValues_pos    = toint( fspan(0,N1,nLabels) )

XBLabels_pos    = new(nLabels,&quot;string&quot;)

do i=0,nLabels-1

x = lonXsecUser(XBValues_pos(i))

y = latXsecUser(XBValues_pos(i))

if(x.lt.180)then
XBLabels_pos(i) = sprintf(&quot;%3.1f&quot;, y)+&quot;N&quot;+&quot;~C~&quot;+sprintf(&quot;%3.1f&quot;, x)+&quot;E&quot;

else if(x.gt.180.and.x.le.360)then

x1=360-x

XBLabels_pos(i) = sprintf(&quot;%3.1f&quot;, y)+&quot;N&quot;+&quot;~C~&quot;+sprintf(&quot;%3.1f&quot;,x1)+&quot;W&quot;

else if(x.eq.180.or.x.eq.360)then

XBLabels_pos(i) = sprintf(&quot;%5.1f&quot;, y)+&quot;N&quot;+&quot;~C~&quot;+sprintf(&quot;%5.1f&quot;, x)
end if

end if

end if

end do

res@tmXBMode   = &quot;Explicit&quot;

res@tmXBValues = XBValues_pos

res@tmXBLabels = XBLabels_pos
</code></pre>
<p>å›¾ç‰‡ç±»ä¼¼è¿™æ ·å§ï¼<br>
<img src="https://RanX79.github.io//post-images/1710485272971.png" alt="" loading="lazy"></p>
<p>psï¼šæœ€è¿‘è¯»æ–‡çŒ®æ‰å‘ç°ï¼Œçœ‹ä½ ç ”ç©¶æ–¹å‘çƒ­ä¸çƒ­é—¨ï¼Œå°±çœ‹çœ‹é«˜è´¨é‡æœŸåˆŠæ–°å‡ºçš„æ–‡ç« è·Ÿä½ çš„æ–¹å‘å·®ä¸å¤šçš„å¤šä¸å¤šï¼›ç„¶åå‘ç°æˆ‘çš„æ–¹å‘çœŸï¼ç¦»å¤§è°±ï¼ï¼ˆä¸æ˜¯ æˆ‘çˆ±ç§‘ç ”</p>
]]></content>
    </entry>
</feed>